import sys
import os
import time
import json
from datetime import datetime
from crew import JobPostingCrew
from config import config
from google.api_core.exceptions import ResourceExhausted

class OutputManager:
    """
    Manages output formatting and file operations for the Job Posting Crew
    """
    
    def __init__(self, base_dir: str = "job_postings_output"):
        self.base_dir = base_dir
        self.ensure_directory_exists()
    
    def ensure_directory_exists(self):
        """Create the output directory if it doesn't exist"""
        if not os.path.exists(self.base_dir):
            os.makedirs(self.base_dir)
            print(f"✅ Created output directory: {self.base_dir}")
    
    def generate_filename(self, company_name: str = "", role_name: str = "", 
                         file_type: str = "md") -> str:
        """Generate a unique filename with timestamp"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Clean names for filename
        company_clean = self._clean_filename(company_name)
        role_clean = self._clean_filename(role_name)
        
        if company_clean and role_clean:
            filename = f"{company_clean}_{role_clean}_{timestamp}.{file_type}"
        else:
            filename = f"job_posting_{timestamp}.{file_type}"
        
        # Ensure filename isn't too long
        if len(filename) > 100:
            filename = filename[:97] + f".{file_type}"
        
        return filename
    
    def _clean_filename(self, name: str) -> str:
        """Clean a string to be safe for use in filenames"""
        if not name:
            return ""
        # Keep only alphanumeric, spaces, hyphens, and underscores
        cleaned = "".join(c for c in name if c.isalnum() or c in (' ', '-', '_')).strip()
        # Replace spaces with underscores
        return cleaned.replace(' ', '_')
    
    def save_job_posting(self, result, company_name: str = "", 
                        role_name: str = "", inputs: dict = None) -> str:
        """Save job posting to markdown file"""
        filename = self.generate_filename(company_name, role_name, "md")
        filepath = os.path.join(self.base_dir, filename)
        
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                self._write_job_posting_content(f, result, company_name, role_name, inputs)
            
            print(f"✅ Job posting saved to: {filepath}")
            return filepath
        except Exception as e:
            print(f"❌ Error saving job posting file: {e}")
            return None
    
    def save_metadata(self, result, inputs: dict, company_name: str = "", 
                     role_name: str = "") -> str:
        """Save metadata as JSON file"""
        filename = self.generate_filename(company_name, role_name, "json")
        filepath = os.path.join(self.base_dir, filename)
        
        try:
            metadata = {
                "timestamp": datetime.now().isoformat(),
                "company_name": company_name,
                "role_name": role_name,
                "inputs": inputs,
                "output_length": len(str(result)),
                "file_type": "job_posting_metadata"
            }
            
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(metadata, f, indent=2, ensure_ascii=False)
            
            print(f"✅ Metadata saved to: {filepath}")
            return filepath
        except Exception as e:
            print(f"❌ Error saving metadata file: {e}")
            return None
    
    def _write_job_posting_content(self, file_handle, result, 
                                  company_name: str, role_name: str, inputs: dict):
        """Write the job posting content to file"""
        # Header with metadata
        file_handle.write(f"# Job Posting Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
        
        if company_name:
            file_handle.write(f"**Company:** {company_name}\n")
        if role_name:
            file_handle.write(f"**Role:** {role_name}\n")
        
        file_handle.write(f"**Generated by:** Job Posting Crew AI\n\n")
        
        # Input parameters section
        if inputs:
            file_handle.write("## Input Parameters\n\n")
            for key, value in inputs.items():
                file_handle.write(f"- **{key.replace('_', ' ').title()}:** {value}\n")
            file_handle.write("\n")
        
        file_handle.write("---\n\n")
        
        # Main content
        content = str(result.raw) if hasattr(result, 'raw') else str(result)
        file_handle.write(content)
        
        # Footer
        file_handle.write(f"\n\n---\n*Generated on {datetime.now().strftime('%B %d, %Y at %I:%M %p')}*")
    
    def print_formatted_output(self, result, show_metadata: bool = True) -> str:
        """Print formatted output to terminal"""
        print("\n" + "="*80)
        print("🎉 JOB POSTING GENERATION COMPLETED SUCCESSFULLY!")
        print("="*80)
        
        content = str(result.raw) if hasattr(result, 'raw') else str(result)
        
        if show_metadata:
            print(f"\n📊 OUTPUT METADATA:")
            print(f"   • Content Length: {len(content)} characters")
            print(f"   • Generated At: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"   • Output Type: {type(result).__name__}")
        
        print("\n📄 GENERATED JOB POSTING:")
        print("-" * 80)
        print(content)
        print("-" * 80)
        
        return content
    
    def print_summary(self, filepath: str = None, metadata_path: str = None):
        """Print a summary of the operation"""
        print(f"\n📁 FILES CREATED:")
        if filepath:
            print(f"   • Job Posting: {filepath}")
        if metadata_path:
            print(f"   • Metadata: {metadata_path}")
        
        print(f"\n💡 TIP: You can find all generated files in the '{self.base_dir}' directory")
    
    def list_recent_outputs(self, limit: int = 5) -> list:
        """List recent output files"""
        try:
            files = []
            for filename in os.listdir(self.base_dir):
                if filename.endswith('.md'):
                    filepath = os.path.join(self.base_dir, filename)
                    mtime = os.path.getmtime(filepath)
                    files.append((filename, mtime, filepath))
            
            # Sort by modification time (newest first)
            files.sort(key=lambda x: x[1], reverse=True)
            
            return files[:limit]
        except Exception as e:
            print(f"❌ Error listing files: {e}")
            return []
    
    def print_recent_outputs(self, limit: int = 5):
        """Print list of recent output files"""
        files = self.list_recent_outputs(limit)
        
        if not files:
            print(f"No job posting files found in {self.base_dir}")
            return
        
        print(f"\n📋 RECENT JOB POSTINGS (Last {len(files)}):")
        print("-" * 60)
        
        for i, (filename, mtime, filepath) in enumerate(files, 1):
            date_str = datetime.fromtimestamp(mtime).strftime('%Y-%m-%d %H:%M')
            print(f"{i}. {filename}")
            print(f"   Created: {date_str}")
            print(f"   Path: {filepath}")
            print()
    
    def cleanup_old_files(self, days_old: int = 30) -> int:
        """Remove files older than specified days"""
        try:
            current_time = datetime.now().timestamp()
            cutoff_time = current_time - (days_old * 24 * 60 * 60)
            
            removed_count = 0
            for filename in os.listdir(self.base_dir):
                filepath = os.path.join(self.base_dir, filename)
                if os.path.isfile(filepath):
                    file_time = os.path.getmtime(filepath)
                    if file_time < cutoff_time:
                        os.remove(filepath)
                        removed_count += 1
                        print(f"🗑️  Removed old file: {filename}")
            
            if removed_count > 0:
                print(f"✅ Cleaned up {removed_count} old files")
            else:
                print("No old files to clean up")
            
            return removed_count
        except Exception as e:
            print(f"❌ Error during cleanup: {e}")
            return 0

# Initialize output manager
output_manager = OutputManager()

def get_user_inputs():
    """Collect all required inputs from the user"""
    print("\n🎯 JOB POSTING GENERATOR - INPUT COLLECTION")
    print("="*60)
    print("Please provide the following information to generate your job posting:")
    print()
    
    inputs = {}
    
    # Company Domain
    while True:
        company_domain = input("📌 Enter company domain/website (e.g., careers.company.com): ").strip()
        if company_domain:
            inputs['company_domain'] = company_domain
            break
        else:
            print("❌ Company domain is required. Please enter a valid domain.")
    
    # Company Description
    while True:
        print("\n📝 Enter a detailed company description:")
        print("   (Include mission, values, what the company does, etc.)")
        company_description = input("➤ ").strip()
        if company_description:
            inputs['company_description'] = company_description
            break
        else:
            print("❌ Company description is required. Please provide a description.")
    
    # Hiring Needs
    while True:
        print("\n👥 Enter detailed hiring needs:")
        print("   (Role title, location, start date, key requirements, etc.)")
        hiring_needs = input("➤ ").strip()
        if hiring_needs:
            inputs['hiring_needs'] = hiring_needs
            break
        else:
            print("❌ Hiring needs are required. Please specify the role details.")
    
    # Specific Benefits
    while True:
        print("\n💰 Enter specific benefits offered:")
        print("   (Salary range, healthcare, remote work, perks, etc.)")
        specific_benefits = input("➤ ").strip()
        if specific_benefits:
            inputs['specific_benefits'] = specific_benefits
            break
        else:
            print("❌ Benefits information is required. Please list the benefits.")
    
    # Optional: Additional Requirements
    print("\n🎯 Enter any additional requirements or preferences (optional):")
    print("   (Education, certifications, soft skills, etc.)")
    additional_requirements = input("➤ ").strip()
    if additional_requirements:
        inputs['additional_requirements'] = additional_requirements
    
    # Optional: Company Culture Info
    print("\n🏢 Enter additional company culture information (optional):")
    print("   (Work environment, team structure, company values, etc.)")
    culture_info = input("➤ ").strip()
    if culture_info:
        inputs['culture_info'] = culture_info
    
    # Optional: Remote Work Policy
    print("\n🌐 Enter remote work policy (optional):")
    print("   (Fully remote, hybrid, on-site, flexible, etc.)")
    remote_policy = input("➤ ").strip()
    if remote_policy:
        inputs['remote_policy'] = remote_policy
    
    # Confirmation
    print("\n" + "="*60)
    print("📋 SUMMARY OF PROVIDED INFORMATION:")
    print("="*60)
    for key, value in inputs.items():
        display_key = key.replace('_', ' ').title()
        print(f"{display_key}: {value[:100]}{'...' if len(value) > 100 else ''}")
    
    print("\n" + "="*60)
    while True:
        confirm = input("✅ Is this information correct? (yes/no/edit): ").strip().lower()
        if confirm in ['yes', 'y']:
            return inputs
        elif confirm in ['no', 'n']:
            print("❌ Operation cancelled.")
            return None
        elif confirm in ['edit', 'e']:
            return edit_inputs(inputs)
        else:
            print("Please enter 'yes', 'no', or 'edit'")

def edit_inputs(inputs):
    """Allow user to edit specific inputs"""
    print("\n📝 EDIT MODE - Select what you'd like to modify:")
    input_keys = list(inputs.keys())
    
    for i, key in enumerate(input_keys, 1):
        display_key = key.replace('_', ' ').title()
        print(f"{i}. {display_key}")
    
    print(f"{len(input_keys) + 1}. Add new field")
    print(f"{len(input_keys) + 2}. Finish editing")
    
    while True:
        try:
            choice = input("\nEnter your choice (number): ").strip()
            choice_num = int(choice)
            
            if 1 <= choice_num <= len(input_keys):
                key = input_keys[choice_num - 1]
                display_key = key.replace('_', ' ').title()
                print(f"\nCurrent value for {display_key}:")
                print(f"➤ {inputs[key]}")
                new_value = input(f"\nEnter new value for {display_key}: ").strip()
                if new_value:
                    inputs[key] = new_value
                    print(f"✅ Updated {display_key}")
                else:
                    print("❌ No changes made (empty input)")
                    
            elif choice_num == len(input_keys) + 1:
                # Add new field
                new_key = input("Enter new field name: ").strip().lower().replace(' ', '_')
                if new_key and new_key not in inputs:
                    new_value = input(f"Enter value for {new_key}: ").strip()
                    if new_value:
                        inputs[new_key] = new_value
                        print(f"✅ Added {new_key}")
                    else:
                        print("❌ No field added (empty value)")
                else:
                    print("❌ Invalid field name or field already exists")
                    
            elif choice_num == len(input_keys) + 2:
                break
            else:
                print("❌ Invalid choice")
                
        except ValueError:
            print("❌ Please enter a valid number")
    
    return inputs

def process_and_save_output(result, inputs, company_name="", role_name=""):
    """Process the result and save to both terminal and file"""
    # Print formatted output to terminal
    content = output_manager.print_formatted_output(result)
    
    # Save job posting to file
    filepath = output_manager.save_job_posting(result, company_name, role_name, inputs)
    
    # Save metadata
    metadata_path = output_manager.save_metadata(result, inputs, company_name, role_name)
    
    # Print summary
    output_manager.print_summary(filepath, metadata_path)
    
    return filepath, metadata_path

def run_with_rate_limiting(inputs):
    """
    Run the crew with proper rate limiting and error handling.
    """
    # Validate configuration
    if not config.validate_required_keys():
        print("Please set up your API keys before running the application.")
        return None
    
    max_retries = 3
    retry_count = 0
    
    while retry_count < max_retries:
        try:
            print(f"\n{'='*50}")
            print(f"🚀 Starting job posting creation (Attempt {retry_count + 1}/{max_retries})")
            print(f"{'='*50}")
            
            # Add initial delay to avoid immediate rate limiting
            if retry_count > 0:
                config.handle_rate_limit()
            else:
                config.wait_between_requests()
            
            job_posting_crew = JobPostingCrew()
            result = job_posting_crew.crew().kickoff(inputs=inputs)
            
            # Extract company and role names for filename
            company_name = inputs.get('company_domain', 'company').replace('.', '_').replace('/', '_')
            role_name = inputs.get('hiring_needs', 'role').split(',')[0].strip().replace(' ', '_')
            
            # Process and save output
            filepath, metadata_path = process_and_save_output(result, inputs, company_name, role_name)
            
            print("\n" + "="*50)
            print("✅ Job posting creation completed successfully!")
            print("="*50)
            return result
            
        except ResourceExhausted as e:
            retry_count += 1
            print(f"\n❌ Rate limit exceeded (Attempt {retry_count}/{max_retries})")
            print(f"Error: {e}")
            
            if retry_count < max_retries:
                print(f"Retrying in {config.RATE_LIMIT_DELAY} seconds...")
                config.handle_rate_limit()
            else:
                print("❌ Maximum retries reached. Please try again later.")
                print("💡 Tip: Consider upgrading your Gemini API plan for higher rate limits.")
                return None
                
        except Exception as e:
            print(f"❌ An unexpected error occurred: {e}")
            retry_count += 1
            if retry_count < max_retries:
                print(f"Retrying in {config.REQUEST_DELAY} seconds...")
                config.wait_between_requests()
            else:
                print("❌ Maximum retries reached due to errors.")
                raise e
    
    return None

def run():
    """
    Run the crew with user-provided inputs.
    """
    inputs = get_user_inputs()
    if inputs is None:
        print("❌ No inputs provided. Exiting.")
        return None
    
    return run_with_rate_limiting(inputs)

def train():
    """
    Train the crew for a given number of iterations.
    """
    # Validate configuration
    if not config.validate_required_keys():
        print("Please set up your API keys before training the application.")
        return
    
    # Get training inputs from user
    print("🎓 TRAINING MODE")
    print("You need to provide sample data for training the AI crew.")
    inputs = get_user_inputs()
    if inputs is None:
        print("❌ Training cancelled. No inputs provided.")
        return
    
    try:
        if len(sys.argv) < 3:
            print("Please provide the number of iterations as an argument.")
            print("Usage: python main.py train <number_of_iterations>")
            return
            
        n_iterations = int(sys.argv[2])
        
        print(f"⚠️  Training with rate limiting may take significantly longer due to API limits.")
        print(f"Estimated time: {n_iterations * 5} minutes minimum")
        
        job_posting_crew = JobPostingCrew()
        
        # Add delays between training iterations
        for i in range(n_iterations):
            print(f"\n📚 Training iteration {i+1}/{n_iterations}")
            if i > 0:
                config.handle_rate_limit()  # Longer delay between iterations
            
            try:
                job_posting_crew.crew().train(n_iterations=1, inputs=inputs)
                print(f"✅ Iteration {i+1} completed")
            except ResourceExhausted:
                print(f"⏸️  Rate limit hit during iteration {i+1}, waiting...")
                config.handle_rate_limit()
                # Retry the iteration
                job_posting_crew.crew().train(n_iterations=1, inputs=inputs)
                print(f"✅ Iteration {i+1} completed after retry")
        
        print(f"🎉 Training completed for {n_iterations} iterations!")
        
    except ValueError:
        print("Please provide a valid number for iterations.")
    except Exception as e:
        print(f"An error occurred while training the crew: {e}")
        raise e

def quick_start_mode():
    """Quick start mode with minimal required inputs"""
    print("\n⚡ QUICK START MODE")
    print("="*40)
    print("Provide minimal information for a quick job posting:")
    
    inputs = {}
    
    # Only ask for essential information
    inputs['company_domain'] = input("Company website: ").strip()
    inputs['company_description'] = input("Company description (brief): ").strip()
    inputs['hiring_needs'] = input("Job title and key details: ").strip()
    inputs['specific_benefits'] = input("Main benefits offered: ").strip()
    
    # Validate essential fields
    required_fields = ['company_domain', 'company_description', 'hiring_needs', 'specific_benefits']
    for field in required_fields:
        if not inputs.get(field):
            print(f"❌ {field.replace('_', ' ').title()} is required for quick start mode.")
            return None
    
    print("\n🚀 Generating job posting with quick start inputs...")
    return run_with_rate_limiting(inputs)

def show_help():
    """Display help information"""
    print("\n🔧 JOB POSTING GENERATOR - HELP")
    print("="*50)
    print("Available commands:")
    print()
    print("🎯 MAIN MODES:")
    print("  python main.py                    - Interactive mode (full input collection)")
    print("  python main.py quick              - Quick start mode (minimal inputs)")
    print()
    print("🎓 TRAINING:")
    print("  python main.py train <n>          - Train the crew for n iterations")
    print()
    print("📁 FILE MANAGEMENT:")
    print("  python main.py list               - List recent job postings")
    print("  python main.py cleanup [days]     - Clean up files older than [days] (default: 30)")
    print()
    print("ℹ️  INFORMATION:")
    print("  python main.py help               - Show this help message")
    print()
    print("📋 REQUIRED INPUTS:")
    print("  • Company domain/website")
    print("  • Company description")
    print("  • Hiring needs (role details)")
    print("  • Specific benefits")
    print()
    print("📋 OPTIONAL INPUTS:")
    print("  • Additional requirements")
    print("  • Company culture information")
    print("  • Remote work policy")
    print()
    print("💡 TIPS:")
    print("  • Be specific and detailed in your inputs for better results")
    print("  • The AI will analyze your company website for additional context")
    print("  • Generated job postings are saved to 'job_postings_output' folder")
    print("  • Use 'edit' option during confirmation to modify inputs")

if __name__ == "__main__":
    print("🚀 Job Posting Crew Starting...")
    print("⚠️  Note: This application includes rate limiting to respect API quotas.")
    
    if len(sys.argv) > 1:
        command = sys.argv[1].lower()
        
        if command == "train":
            train()
        elif command == "quick":
            result = quick_start_mode()
            if result:
                print(f"\n🎉 Quick start process completed successfully!")
        elif command == "list":
            print("📋 Recent Job Postings:")
            output_manager.print_recent_outputs()
        elif command == "cleanup":
            days = int(sys.argv[2]) if len(sys.argv) > 2 else 30
            output_manager.cleanup_old_files(days)
        elif command in ["help", "-h", "--help"]:
            show_help()
        else:
            print(f"❌ Unknown command: {command}")
            show_help()
    else:
        # Default interactive mode
        result = run()
        if result:
            print(f"\n🎉 Process completed successfully!")
            print("📁 Check the 'job_postings_output' folder for the saved files.")
            print("💡 Use 'python main.py list' to see recent outputs.")